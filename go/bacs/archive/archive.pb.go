// Code generated by protoc-gen-go. DO NOT EDIT.
// source: bacs/archive/archive.proto

/*
Package archive is a generated protocol buffer package.

It is generated from these files:
	bacs/archive/archive.proto

It has these top-level messages:
	Chunk
	DownloadRequest
	RenameRequest
	ChangeFlagsRequest
	ArchiveRevision
	CachedStatusMap
	ArchiveServiceConfig
	ArchiveServerConfig
*/
package archive

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import bacs_archive_problem "bacs/archive/problem"
import bacs_archive_problem1 "bacs/archive/problem"
import bacs_archive_problem3 "bacs/archive/problem"
import bacs_archive_problem4 "bacs/archive/problem"
import bacs_utility "bacs/utility"
import google_protobuf1 "github.com/golang/protobuf/ptypes/empty"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Chunk struct {
	Format *bacs_utility.Archiver `protobuf:"bytes,1,opt,name=format" json:"format,omitempty"`
	Data   []byte                 `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *Chunk) Reset()                    { *m = Chunk{} }
func (m *Chunk) String() string            { return proto.CompactTextString(m) }
func (*Chunk) ProtoMessage()               {}
func (*Chunk) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Chunk) GetFormat() *bacs_utility.Archiver {
	if m != nil {
		return m.Format
	}
	return nil
}

func (m *Chunk) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type DownloadRequest struct {
	Ids    *bacs_archive_problem1.IdSet `protobuf:"bytes,1,opt,name=ids" json:"ids,omitempty"`
	Format *bacs_utility.Archiver       `protobuf:"bytes,2,opt,name=format" json:"format,omitempty"`
}

func (m *DownloadRequest) Reset()                    { *m = DownloadRequest{} }
func (m *DownloadRequest) String() string            { return proto.CompactTextString(m) }
func (*DownloadRequest) ProtoMessage()               {}
func (*DownloadRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *DownloadRequest) GetIds() *bacs_archive_problem1.IdSet {
	if m != nil {
		return m.Ids
	}
	return nil
}

func (m *DownloadRequest) GetFormat() *bacs_utility.Archiver {
	if m != nil {
		return m.Format
	}
	return nil
}

type RenameRequest struct {
	From string `protobuf:"bytes,1,opt,name=from" json:"from,omitempty"`
	To   string `protobuf:"bytes,2,opt,name=to" json:"to,omitempty"`
}

func (m *RenameRequest) Reset()                    { *m = RenameRequest{} }
func (m *RenameRequest) String() string            { return proto.CompactTextString(m) }
func (*RenameRequest) ProtoMessage()               {}
func (*RenameRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *RenameRequest) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *RenameRequest) GetTo() string {
	if m != nil {
		return m.To
	}
	return ""
}

type ChangeFlagsRequest struct {
	Ids  *bacs_archive_problem1.IdSet  `protobuf:"bytes,1,opt,name=ids" json:"ids,omitempty"`
	Flag *bacs_archive_problem.FlagSet `protobuf:"bytes,2,opt,name=flag" json:"flag,omitempty"`
}

func (m *ChangeFlagsRequest) Reset()                    { *m = ChangeFlagsRequest{} }
func (m *ChangeFlagsRequest) String() string            { return proto.CompactTextString(m) }
func (*ChangeFlagsRequest) ProtoMessage()               {}
func (*ChangeFlagsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *ChangeFlagsRequest) GetIds() *bacs_archive_problem1.IdSet {
	if m != nil {
		return m.Ids
	}
	return nil
}

func (m *ChangeFlagsRequest) GetFlag() *bacs_archive_problem.FlagSet {
	if m != nil {
		return m.Flag
	}
	return nil
}

// Archive revision which changes if any problem is modified.
// Empty revision is never used by the server and can be safely used
// as initial value.
type ArchiveRevision struct {
	Value []byte `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *ArchiveRevision) Reset()                    { *m = ArchiveRevision{} }
func (m *ArchiveRevision) String() string            { return proto.CompactTextString(m) }
func (*ArchiveRevision) ProtoMessage()               {}
func (*ArchiveRevision) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *ArchiveRevision) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type CachedStatusMap struct {
	Status   *bacs_archive_problem4.StatusMap `protobuf:"bytes,1,opt,name=status" json:"status,omitempty"`
	Revision *ArchiveRevision                 `protobuf:"bytes,2,opt,name=revision" json:"revision,omitempty"`
}

func (m *CachedStatusMap) Reset()                    { *m = CachedStatusMap{} }
func (m *CachedStatusMap) String() string            { return proto.CompactTextString(m) }
func (*CachedStatusMap) ProtoMessage()               {}
func (*CachedStatusMap) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *CachedStatusMap) GetStatus() *bacs_archive_problem4.StatusMap {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *CachedStatusMap) GetRevision() *ArchiveRevision {
	if m != nil {
		return m.Revision
	}
	return nil
}

// Configuration
type ArchiveServiceConfig struct {
	UploadDirectory string                            `protobuf:"bytes,1,opt,name=upload_directory,json=uploadDirectory" json:"upload_directory,omitempty"`
	Permissions     *ArchiveServiceConfig_Permissions `protobuf:"bytes,2,opt,name=permissions" json:"permissions,omitempty"`
}

func (m *ArchiveServiceConfig) Reset()                    { *m = ArchiveServiceConfig{} }
func (m *ArchiveServiceConfig) String() string            { return proto.CompactTextString(m) }
func (*ArchiveServiceConfig) ProtoMessage()               {}
func (*ArchiveServiceConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *ArchiveServiceConfig) GetUploadDirectory() string {
	if m != nil {
		return m.UploadDirectory
	}
	return ""
}

func (m *ArchiveServiceConfig) GetPermissions() *ArchiveServiceConfig_Permissions {
	if m != nil {
		return m.Permissions
	}
	return nil
}

type ArchiveServiceConfig_Permissions struct {
	AllowAny    bool                                     `protobuf:"varint,1,opt,name=allow_any,json=allowAny" json:"allow_any,omitempty"`
	AllowedUser []*ArchiveServiceConfig_Permissions_User `protobuf:"bytes,2,rep,name=allowed_user,json=allowedUser" json:"allowed_user,omitempty"`
}

func (m *ArchiveServiceConfig_Permissions) Reset()         { *m = ArchiveServiceConfig_Permissions{} }
func (m *ArchiveServiceConfig_Permissions) String() string { return proto.CompactTextString(m) }
func (*ArchiveServiceConfig_Permissions) ProtoMessage()    {}
func (*ArchiveServiceConfig_Permissions) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{6, 0}
}

func (m *ArchiveServiceConfig_Permissions) GetAllowAny() bool {
	if m != nil {
		return m.AllowAny
	}
	return false
}

func (m *ArchiveServiceConfig_Permissions) GetAllowedUser() []*ArchiveServiceConfig_Permissions_User {
	if m != nil {
		return m.AllowedUser
	}
	return nil
}

type ArchiveServiceConfig_Permissions_User struct {
	Identity []string `protobuf:"bytes,1,rep,name=identity" json:"identity,omitempty"`
}

func (m *ArchiveServiceConfig_Permissions_User) Reset()         { *m = ArchiveServiceConfig_Permissions_User{} }
func (m *ArchiveServiceConfig_Permissions_User) String() string { return proto.CompactTextString(m) }
func (*ArchiveServiceConfig_Permissions_User) ProtoMessage()    {}
func (*ArchiveServiceConfig_Permissions_User) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{6, 0, 0}
}

func (m *ArchiveServiceConfig_Permissions_User) GetIdentity() []string {
	if m != nil {
		return m.Identity
	}
	return nil
}

type ArchiveServerConfig struct {
	Listen  string                `protobuf:"bytes,1,opt,name=listen" json:"listen,omitempty"`
	Service *ArchiveServiceConfig `protobuf:"bytes,2,opt,name=service" json:"service,omitempty"`
	// Types that are valid to be assigned to Credentials:
	//	*ArchiveServerConfig_SslCredentials_
	Credentials isArchiveServerConfig_Credentials `protobuf_oneof:"credentials"`
}

func (m *ArchiveServerConfig) Reset()                    { *m = ArchiveServerConfig{} }
func (m *ArchiveServerConfig) String() string            { return proto.CompactTextString(m) }
func (*ArchiveServerConfig) ProtoMessage()               {}
func (*ArchiveServerConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

type isArchiveServerConfig_Credentials interface {
	isArchiveServerConfig_Credentials()
}

type ArchiveServerConfig_SslCredentials_ struct {
	SslCredentials *ArchiveServerConfig_SslCredentials `protobuf:"bytes,3,opt,name=ssl_credentials,json=sslCredentials,oneof"`
}

func (*ArchiveServerConfig_SslCredentials_) isArchiveServerConfig_Credentials() {}

func (m *ArchiveServerConfig) GetCredentials() isArchiveServerConfig_Credentials {
	if m != nil {
		return m.Credentials
	}
	return nil
}

func (m *ArchiveServerConfig) GetListen() string {
	if m != nil {
		return m.Listen
	}
	return ""
}

func (m *ArchiveServerConfig) GetService() *ArchiveServiceConfig {
	if m != nil {
		return m.Service
	}
	return nil
}

func (m *ArchiveServerConfig) GetSslCredentials() *ArchiveServerConfig_SslCredentials {
	if x, ok := m.GetCredentials().(*ArchiveServerConfig_SslCredentials_); ok {
		return x.SslCredentials
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ArchiveServerConfig) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ArchiveServerConfig_OneofMarshaler, _ArchiveServerConfig_OneofUnmarshaler, _ArchiveServerConfig_OneofSizer, []interface{}{
		(*ArchiveServerConfig_SslCredentials_)(nil),
	}
}

func _ArchiveServerConfig_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ArchiveServerConfig)
	// credentials
	switch x := m.Credentials.(type) {
	case *ArchiveServerConfig_SslCredentials_:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SslCredentials); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ArchiveServerConfig.Credentials has unexpected type %T", x)
	}
	return nil
}

func _ArchiveServerConfig_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ArchiveServerConfig)
	switch tag {
	case 3: // credentials.ssl_credentials
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ArchiveServerConfig_SslCredentials)
		err := b.DecodeMessage(msg)
		m.Credentials = &ArchiveServerConfig_SslCredentials_{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ArchiveServerConfig_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ArchiveServerConfig)
	// credentials
	switch x := m.Credentials.(type) {
	case *ArchiveServerConfig_SslCredentials_:
		s := proto.Size(x.SslCredentials)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ArchiveServerConfig_SslCredentials struct {
	PemRootCertsPath string                                               `protobuf:"bytes,1,opt,name=pem_root_certs_path,json=pemRootCertsPath" json:"pem_root_certs_path,omitempty"`
	PemKeyCertPair   []*ArchiveServerConfig_SslCredentials_PemKeyCertPair `protobuf:"bytes,2,rep,name=pem_key_cert_pair,json=pemKeyCertPair" json:"pem_key_cert_pair,omitempty"`
	ForceClientAuth  bool                                                 `protobuf:"varint,3,opt,name=force_client_auth,json=forceClientAuth" json:"force_client_auth,omitempty"`
}

func (m *ArchiveServerConfig_SslCredentials) Reset()         { *m = ArchiveServerConfig_SslCredentials{} }
func (m *ArchiveServerConfig_SslCredentials) String() string { return proto.CompactTextString(m) }
func (*ArchiveServerConfig_SslCredentials) ProtoMessage()    {}
func (*ArchiveServerConfig_SslCredentials) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{7, 0}
}

func (m *ArchiveServerConfig_SslCredentials) GetPemRootCertsPath() string {
	if m != nil {
		return m.PemRootCertsPath
	}
	return ""
}

func (m *ArchiveServerConfig_SslCredentials) GetPemKeyCertPair() []*ArchiveServerConfig_SslCredentials_PemKeyCertPair {
	if m != nil {
		return m.PemKeyCertPair
	}
	return nil
}

func (m *ArchiveServerConfig_SslCredentials) GetForceClientAuth() bool {
	if m != nil {
		return m.ForceClientAuth
	}
	return false
}

type ArchiveServerConfig_SslCredentials_PemKeyCertPair struct {
	PrivateKeyPath string `protobuf:"bytes,1,opt,name=private_key_path,json=privateKeyPath" json:"private_key_path,omitempty"`
	CertChainPath  string `protobuf:"bytes,2,opt,name=cert_chain_path,json=certChainPath" json:"cert_chain_path,omitempty"`
}

func (m *ArchiveServerConfig_SslCredentials_PemKeyCertPair) Reset() {
	*m = ArchiveServerConfig_SslCredentials_PemKeyCertPair{}
}
func (m *ArchiveServerConfig_SslCredentials_PemKeyCertPair) String() string {
	return proto.CompactTextString(m)
}
func (*ArchiveServerConfig_SslCredentials_PemKeyCertPair) ProtoMessage() {}
func (*ArchiveServerConfig_SslCredentials_PemKeyCertPair) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{7, 0, 0}
}

func (m *ArchiveServerConfig_SslCredentials_PemKeyCertPair) GetPrivateKeyPath() string {
	if m != nil {
		return m.PrivateKeyPath
	}
	return ""
}

func (m *ArchiveServerConfig_SslCredentials_PemKeyCertPair) GetCertChainPath() string {
	if m != nil {
		return m.CertChainPath
	}
	return ""
}

func init() {
	proto.RegisterType((*Chunk)(nil), "bacs.archive.Chunk")
	proto.RegisterType((*DownloadRequest)(nil), "bacs.archive.DownloadRequest")
	proto.RegisterType((*RenameRequest)(nil), "bacs.archive.RenameRequest")
	proto.RegisterType((*ChangeFlagsRequest)(nil), "bacs.archive.ChangeFlagsRequest")
	proto.RegisterType((*ArchiveRevision)(nil), "bacs.archive.ArchiveRevision")
	proto.RegisterType((*CachedStatusMap)(nil), "bacs.archive.CachedStatusMap")
	proto.RegisterType((*ArchiveServiceConfig)(nil), "bacs.archive.ArchiveServiceConfig")
	proto.RegisterType((*ArchiveServiceConfig_Permissions)(nil), "bacs.archive.ArchiveServiceConfig.Permissions")
	proto.RegisterType((*ArchiveServiceConfig_Permissions_User)(nil), "bacs.archive.ArchiveServiceConfig.Permissions.User")
	proto.RegisterType((*ArchiveServerConfig)(nil), "bacs.archive.ArchiveServerConfig")
	proto.RegisterType((*ArchiveServerConfig_SslCredentials)(nil), "bacs.archive.ArchiveServerConfig.SslCredentials")
	proto.RegisterType((*ArchiveServerConfig_SslCredentials_PemKeyCertPair)(nil), "bacs.archive.ArchiveServerConfig.SslCredentials.PemKeyCertPair")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Archive service

type ArchiveClient interface {
	Upload(ctx context.Context, opts ...grpc.CallOption) (Archive_UploadClient, error)
	Download(ctx context.Context, in *DownloadRequest, opts ...grpc.CallOption) (Archive_DownloadClient, error)
	Rename(ctx context.Context, in *RenameRequest, opts ...grpc.CallOption) (*bacs_archive_problem4.StatusResult, error)
	Existing(ctx context.Context, in *bacs_archive_problem1.IdSet, opts ...grpc.CallOption) (*bacs_archive_problem1.IdSet, error)
	ExistingAll(ctx context.Context, in *google_protobuf1.Empty, opts ...grpc.CallOption) (*bacs_archive_problem1.IdSet, error)
	Status(ctx context.Context, in *bacs_archive_problem1.IdSet, opts ...grpc.CallOption) (*bacs_archive_problem4.StatusMap, error)
	StatusAll(ctx context.Context, in *google_protobuf1.Empty, opts ...grpc.CallOption) (*bacs_archive_problem4.StatusMap, error)
	// Returns CachedStatusMap with empty status if revision is unchanged.
	StatusAllIfChanged(ctx context.Context, in *ArchiveRevision, opts ...grpc.CallOption) (*CachedStatusMap, error)
	ImportResult(ctx context.Context, in *bacs_archive_problem1.IdSet, opts ...grpc.CallOption) (*bacs_archive_problem3.ImportMap, error)
	Import(ctx context.Context, in *bacs_archive_problem1.IdSet, opts ...grpc.CallOption) (*bacs_archive_problem4.StatusMap, error)
	ImportAll(ctx context.Context, in *google_protobuf1.Empty, opts ...grpc.CallOption) (*bacs_archive_problem4.StatusMap, error)
	// Flag API is not stable. Not intended for public usage.
	WithFlag(ctx context.Context, in *bacs_archive_problem1.IdSet, opts ...grpc.CallOption) (*bacs_archive_problem1.IdSet, error)
	WithFlagAll(ctx context.Context, in *google_protobuf1.Empty, opts ...grpc.CallOption) (*bacs_archive_problem1.IdSet, error)
	SetFlags(ctx context.Context, in *ChangeFlagsRequest, opts ...grpc.CallOption) (*bacs_archive_problem4.StatusMap, error)
	UnsetFlags(ctx context.Context, in *ChangeFlagsRequest, opts ...grpc.CallOption) (*bacs_archive_problem4.StatusMap, error)
	ClearFlags(ctx context.Context, in *bacs_archive_problem1.IdSet, opts ...grpc.CallOption) (*bacs_archive_problem4.StatusMap, error)
}

type archiveClient struct {
	cc *grpc.ClientConn
}

func NewArchiveClient(cc *grpc.ClientConn) ArchiveClient {
	return &archiveClient{cc}
}

func (c *archiveClient) Upload(ctx context.Context, opts ...grpc.CallOption) (Archive_UploadClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Archive_serviceDesc.Streams[0], c.cc, "/bacs.archive.Archive/Upload", opts...)
	if err != nil {
		return nil, err
	}
	x := &archiveUploadClient{stream}
	return x, nil
}

type Archive_UploadClient interface {
	Send(*Chunk) error
	CloseAndRecv() (*bacs_archive_problem4.StatusMap, error)
	grpc.ClientStream
}

type archiveUploadClient struct {
	grpc.ClientStream
}

func (x *archiveUploadClient) Send(m *Chunk) error {
	return x.ClientStream.SendMsg(m)
}

func (x *archiveUploadClient) CloseAndRecv() (*bacs_archive_problem4.StatusMap, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(bacs_archive_problem4.StatusMap)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *archiveClient) Download(ctx context.Context, in *DownloadRequest, opts ...grpc.CallOption) (Archive_DownloadClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Archive_serviceDesc.Streams[1], c.cc, "/bacs.archive.Archive/Download", opts...)
	if err != nil {
		return nil, err
	}
	x := &archiveDownloadClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Archive_DownloadClient interface {
	Recv() (*Chunk, error)
	grpc.ClientStream
}

type archiveDownloadClient struct {
	grpc.ClientStream
}

func (x *archiveDownloadClient) Recv() (*Chunk, error) {
	m := new(Chunk)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *archiveClient) Rename(ctx context.Context, in *RenameRequest, opts ...grpc.CallOption) (*bacs_archive_problem4.StatusResult, error) {
	out := new(bacs_archive_problem4.StatusResult)
	err := grpc.Invoke(ctx, "/bacs.archive.Archive/Rename", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *archiveClient) Existing(ctx context.Context, in *bacs_archive_problem1.IdSet, opts ...grpc.CallOption) (*bacs_archive_problem1.IdSet, error) {
	out := new(bacs_archive_problem1.IdSet)
	err := grpc.Invoke(ctx, "/bacs.archive.Archive/Existing", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *archiveClient) ExistingAll(ctx context.Context, in *google_protobuf1.Empty, opts ...grpc.CallOption) (*bacs_archive_problem1.IdSet, error) {
	out := new(bacs_archive_problem1.IdSet)
	err := grpc.Invoke(ctx, "/bacs.archive.Archive/ExistingAll", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *archiveClient) Status(ctx context.Context, in *bacs_archive_problem1.IdSet, opts ...grpc.CallOption) (*bacs_archive_problem4.StatusMap, error) {
	out := new(bacs_archive_problem4.StatusMap)
	err := grpc.Invoke(ctx, "/bacs.archive.Archive/Status", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *archiveClient) StatusAll(ctx context.Context, in *google_protobuf1.Empty, opts ...grpc.CallOption) (*bacs_archive_problem4.StatusMap, error) {
	out := new(bacs_archive_problem4.StatusMap)
	err := grpc.Invoke(ctx, "/bacs.archive.Archive/StatusAll", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *archiveClient) StatusAllIfChanged(ctx context.Context, in *ArchiveRevision, opts ...grpc.CallOption) (*CachedStatusMap, error) {
	out := new(CachedStatusMap)
	err := grpc.Invoke(ctx, "/bacs.archive.Archive/StatusAllIfChanged", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *archiveClient) ImportResult(ctx context.Context, in *bacs_archive_problem1.IdSet, opts ...grpc.CallOption) (*bacs_archive_problem3.ImportMap, error) {
	out := new(bacs_archive_problem3.ImportMap)
	err := grpc.Invoke(ctx, "/bacs.archive.Archive/ImportResult", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *archiveClient) Import(ctx context.Context, in *bacs_archive_problem1.IdSet, opts ...grpc.CallOption) (*bacs_archive_problem4.StatusMap, error) {
	out := new(bacs_archive_problem4.StatusMap)
	err := grpc.Invoke(ctx, "/bacs.archive.Archive/Import", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *archiveClient) ImportAll(ctx context.Context, in *google_protobuf1.Empty, opts ...grpc.CallOption) (*bacs_archive_problem4.StatusMap, error) {
	out := new(bacs_archive_problem4.StatusMap)
	err := grpc.Invoke(ctx, "/bacs.archive.Archive/ImportAll", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *archiveClient) WithFlag(ctx context.Context, in *bacs_archive_problem1.IdSet, opts ...grpc.CallOption) (*bacs_archive_problem1.IdSet, error) {
	out := new(bacs_archive_problem1.IdSet)
	err := grpc.Invoke(ctx, "/bacs.archive.Archive/WithFlag", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *archiveClient) WithFlagAll(ctx context.Context, in *google_protobuf1.Empty, opts ...grpc.CallOption) (*bacs_archive_problem1.IdSet, error) {
	out := new(bacs_archive_problem1.IdSet)
	err := grpc.Invoke(ctx, "/bacs.archive.Archive/WithFlagAll", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *archiveClient) SetFlags(ctx context.Context, in *ChangeFlagsRequest, opts ...grpc.CallOption) (*bacs_archive_problem4.StatusMap, error) {
	out := new(bacs_archive_problem4.StatusMap)
	err := grpc.Invoke(ctx, "/bacs.archive.Archive/SetFlags", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *archiveClient) UnsetFlags(ctx context.Context, in *ChangeFlagsRequest, opts ...grpc.CallOption) (*bacs_archive_problem4.StatusMap, error) {
	out := new(bacs_archive_problem4.StatusMap)
	err := grpc.Invoke(ctx, "/bacs.archive.Archive/UnsetFlags", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *archiveClient) ClearFlags(ctx context.Context, in *bacs_archive_problem1.IdSet, opts ...grpc.CallOption) (*bacs_archive_problem4.StatusMap, error) {
	out := new(bacs_archive_problem4.StatusMap)
	err := grpc.Invoke(ctx, "/bacs.archive.Archive/ClearFlags", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Archive service

type ArchiveServer interface {
	Upload(Archive_UploadServer) error
	Download(*DownloadRequest, Archive_DownloadServer) error
	Rename(context.Context, *RenameRequest) (*bacs_archive_problem4.StatusResult, error)
	Existing(context.Context, *bacs_archive_problem1.IdSet) (*bacs_archive_problem1.IdSet, error)
	ExistingAll(context.Context, *google_protobuf1.Empty) (*bacs_archive_problem1.IdSet, error)
	Status(context.Context, *bacs_archive_problem1.IdSet) (*bacs_archive_problem4.StatusMap, error)
	StatusAll(context.Context, *google_protobuf1.Empty) (*bacs_archive_problem4.StatusMap, error)
	// Returns CachedStatusMap with empty status if revision is unchanged.
	StatusAllIfChanged(context.Context, *ArchiveRevision) (*CachedStatusMap, error)
	ImportResult(context.Context, *bacs_archive_problem1.IdSet) (*bacs_archive_problem3.ImportMap, error)
	Import(context.Context, *bacs_archive_problem1.IdSet) (*bacs_archive_problem4.StatusMap, error)
	ImportAll(context.Context, *google_protobuf1.Empty) (*bacs_archive_problem4.StatusMap, error)
	// Flag API is not stable. Not intended for public usage.
	WithFlag(context.Context, *bacs_archive_problem1.IdSet) (*bacs_archive_problem1.IdSet, error)
	WithFlagAll(context.Context, *google_protobuf1.Empty) (*bacs_archive_problem1.IdSet, error)
	SetFlags(context.Context, *ChangeFlagsRequest) (*bacs_archive_problem4.StatusMap, error)
	UnsetFlags(context.Context, *ChangeFlagsRequest) (*bacs_archive_problem4.StatusMap, error)
	ClearFlags(context.Context, *bacs_archive_problem1.IdSet) (*bacs_archive_problem4.StatusMap, error)
}

func RegisterArchiveServer(s *grpc.Server, srv ArchiveServer) {
	s.RegisterService(&_Archive_serviceDesc, srv)
}

func _Archive_Upload_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ArchiveServer).Upload(&archiveUploadServer{stream})
}

type Archive_UploadServer interface {
	SendAndClose(*bacs_archive_problem4.StatusMap) error
	Recv() (*Chunk, error)
	grpc.ServerStream
}

type archiveUploadServer struct {
	grpc.ServerStream
}

func (x *archiveUploadServer) SendAndClose(m *bacs_archive_problem4.StatusMap) error {
	return x.ServerStream.SendMsg(m)
}

func (x *archiveUploadServer) Recv() (*Chunk, error) {
	m := new(Chunk)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Archive_Download_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DownloadRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ArchiveServer).Download(m, &archiveDownloadServer{stream})
}

type Archive_DownloadServer interface {
	Send(*Chunk) error
	grpc.ServerStream
}

type archiveDownloadServer struct {
	grpc.ServerStream
}

func (x *archiveDownloadServer) Send(m *Chunk) error {
	return x.ServerStream.SendMsg(m)
}

func _Archive_Rename_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RenameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArchiveServer).Rename(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bacs.archive.Archive/Rename",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArchiveServer).Rename(ctx, req.(*RenameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Archive_Existing_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(bacs_archive_problem1.IdSet)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArchiveServer).Existing(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bacs.archive.Archive/Existing",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArchiveServer).Existing(ctx, req.(*bacs_archive_problem1.IdSet))
	}
	return interceptor(ctx, in, info, handler)
}

func _Archive_ExistingAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(google_protobuf1.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArchiveServer).ExistingAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bacs.archive.Archive/ExistingAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArchiveServer).ExistingAll(ctx, req.(*google_protobuf1.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Archive_Status_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(bacs_archive_problem1.IdSet)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArchiveServer).Status(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bacs.archive.Archive/Status",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArchiveServer).Status(ctx, req.(*bacs_archive_problem1.IdSet))
	}
	return interceptor(ctx, in, info, handler)
}

func _Archive_StatusAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(google_protobuf1.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArchiveServer).StatusAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bacs.archive.Archive/StatusAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArchiveServer).StatusAll(ctx, req.(*google_protobuf1.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Archive_StatusAllIfChanged_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArchiveRevision)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArchiveServer).StatusAllIfChanged(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bacs.archive.Archive/StatusAllIfChanged",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArchiveServer).StatusAllIfChanged(ctx, req.(*ArchiveRevision))
	}
	return interceptor(ctx, in, info, handler)
}

func _Archive_ImportResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(bacs_archive_problem1.IdSet)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArchiveServer).ImportResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bacs.archive.Archive/ImportResult",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArchiveServer).ImportResult(ctx, req.(*bacs_archive_problem1.IdSet))
	}
	return interceptor(ctx, in, info, handler)
}

func _Archive_Import_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(bacs_archive_problem1.IdSet)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArchiveServer).Import(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bacs.archive.Archive/Import",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArchiveServer).Import(ctx, req.(*bacs_archive_problem1.IdSet))
	}
	return interceptor(ctx, in, info, handler)
}

func _Archive_ImportAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(google_protobuf1.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArchiveServer).ImportAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bacs.archive.Archive/ImportAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArchiveServer).ImportAll(ctx, req.(*google_protobuf1.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Archive_WithFlag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(bacs_archive_problem1.IdSet)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArchiveServer).WithFlag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bacs.archive.Archive/WithFlag",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArchiveServer).WithFlag(ctx, req.(*bacs_archive_problem1.IdSet))
	}
	return interceptor(ctx, in, info, handler)
}

func _Archive_WithFlagAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(google_protobuf1.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArchiveServer).WithFlagAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bacs.archive.Archive/WithFlagAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArchiveServer).WithFlagAll(ctx, req.(*google_protobuf1.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Archive_SetFlags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChangeFlagsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArchiveServer).SetFlags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bacs.archive.Archive/SetFlags",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArchiveServer).SetFlags(ctx, req.(*ChangeFlagsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Archive_UnsetFlags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChangeFlagsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArchiveServer).UnsetFlags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bacs.archive.Archive/UnsetFlags",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArchiveServer).UnsetFlags(ctx, req.(*ChangeFlagsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Archive_ClearFlags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(bacs_archive_problem1.IdSet)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArchiveServer).ClearFlags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bacs.archive.Archive/ClearFlags",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArchiveServer).ClearFlags(ctx, req.(*bacs_archive_problem1.IdSet))
	}
	return interceptor(ctx, in, info, handler)
}

var _Archive_serviceDesc = grpc.ServiceDesc{
	ServiceName: "bacs.archive.Archive",
	HandlerType: (*ArchiveServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Rename",
			Handler:    _Archive_Rename_Handler,
		},
		{
			MethodName: "Existing",
			Handler:    _Archive_Existing_Handler,
		},
		{
			MethodName: "ExistingAll",
			Handler:    _Archive_ExistingAll_Handler,
		},
		{
			MethodName: "Status",
			Handler:    _Archive_Status_Handler,
		},
		{
			MethodName: "StatusAll",
			Handler:    _Archive_StatusAll_Handler,
		},
		{
			MethodName: "StatusAllIfChanged",
			Handler:    _Archive_StatusAllIfChanged_Handler,
		},
		{
			MethodName: "ImportResult",
			Handler:    _Archive_ImportResult_Handler,
		},
		{
			MethodName: "Import",
			Handler:    _Archive_Import_Handler,
		},
		{
			MethodName: "ImportAll",
			Handler:    _Archive_ImportAll_Handler,
		},
		{
			MethodName: "WithFlag",
			Handler:    _Archive_WithFlag_Handler,
		},
		{
			MethodName: "WithFlagAll",
			Handler:    _Archive_WithFlagAll_Handler,
		},
		{
			MethodName: "SetFlags",
			Handler:    _Archive_SetFlags_Handler,
		},
		{
			MethodName: "UnsetFlags",
			Handler:    _Archive_UnsetFlags_Handler,
		},
		{
			MethodName: "ClearFlags",
			Handler:    _Archive_ClearFlags_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Upload",
			Handler:       _Archive_Upload_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "Download",
			Handler:       _Archive_Download_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "bacs/archive/archive.proto",
}

func init() { proto.RegisterFile("bacs/archive/archive.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 951 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0xd1, 0x6e, 0xe3, 0x44,
	0x17, 0xfe, 0x93, 0x66, 0xd3, 0xe4, 0x24, 0x4d, 0xba, 0xd3, 0x55, 0x55, 0xb9, 0x5a, 0x6d, 0x7f,
	0x5f, 0x40, 0x40, 0x5a, 0x77, 0x69, 0x2f, 0x10, 0x12, 0x12, 0xdb, 0x26, 0x5b, 0x51, 0xca, 0x8a,
	0x68, 0xa2, 0x82, 0x04, 0x17, 0xd6, 0xc4, 0x99, 0xc4, 0xc3, 0xda, 0x1e, 0x33, 0x33, 0xce, 0x92,
	0x07, 0xe0, 0x11, 0xe0, 0x11, 0x78, 0x09, 0x78, 0x38, 0x34, 0xe3, 0x71, 0x37, 0x31, 0x21, 0x61,
	0x5b, 0xae, 0xec, 0x39, 0xe7, 0x9b, 0xef, 0x7c, 0xe7, 0x1c, 0xcf, 0x19, 0x83, 0x33, 0x26, 0x81,
	0x3c, 0x25, 0x22, 0x08, 0xd9, 0x9c, 0x16, 0x4f, 0x2f, 0x15, 0x5c, 0x71, 0xd4, 0xd6, 0x3e, 0xcf,
	0xda, 0x9c, 0x67, 0x2b, 0xc8, 0x54, 0xf0, 0x71, 0x44, 0xe3, 0xd3, 0x69, 0x44, 0x66, 0x39, 0xdc,
	0x79, 0xba, 0x16, 0xc0, 0x26, 0xd6, 0xfd, 0xff, 0xf5, 0xee, 0x38, 0xe5, 0x42, 0x6d, 0x84, 0x48,
	0x45, 0x54, 0x26, 0x2d, 0xe4, 0xd8, 0x40, 0x32, 0xc5, 0x22, 0xa6, 0x16, 0x05, 0x54, 0x14, 0xce,
	0x19, 0xe7, 0xb3, 0xc8, 0xec, 0x54, 0x7c, 0x9c, 0x4d, 0x4f, 0x69, 0x9c, 0xaa, 0x45, 0xee, 0x74,
	0x6f, 0xe0, 0x51, 0x3f, 0xcc, 0x92, 0x37, 0xc8, 0x83, 0xfa, 0x94, 0x8b, 0x98, 0xa8, 0xa3, 0xca,
	0x49, 0xa5, 0xd7, 0x3a, 0x3b, 0xf4, 0x4c, 0x9e, 0x96, 0xd3, 0xbb, 0xb0, 0x9c, 0xd8, 0xa2, 0x10,
	0x82, 0xda, 0x84, 0x28, 0x72, 0x54, 0x3d, 0xa9, 0xf4, 0xda, 0xd8, 0xbc, 0xbb, 0x29, 0x74, 0x07,
	0xfc, 0x6d, 0x12, 0x71, 0x32, 0xc1, 0xf4, 0xa7, 0x8c, 0x4a, 0x85, 0x9e, 0xc3, 0x0e, 0x9b, 0x48,
	0xcb, 0x79, 0xec, 0x2d, 0xd7, 0xce, 0xb3, 0xa9, 0x78, 0xd7, 0x93, 0x11, 0x55, 0x58, 0xe3, 0x96,
	0x54, 0x54, 0xff, 0x8d, 0x0a, 0xf7, 0x1c, 0xf6, 0x30, 0x4d, 0x48, 0x4c, 0x8b, 0x78, 0x08, 0x6a,
	0x53, 0xc1, 0x63, 0x13, 0xb0, 0x89, 0xcd, 0x3b, 0xea, 0x40, 0x55, 0x71, 0x43, 0xd8, 0xc4, 0x55,
	0xc5, 0xdd, 0x39, 0xa0, 0x7e, 0x48, 0x92, 0x19, 0xbd, 0x8a, 0xc8, 0x4c, 0xde, 0x53, 0xe9, 0x27,
	0x50, 0xd3, 0x5d, 0xb6, 0x3a, 0x9f, 0xae, 0xc7, 0xeb, 0x00, 0x7a, 0x87, 0x81, 0xba, 0x1f, 0x42,
	0xd7, 0x26, 0x80, 0xe9, 0x9c, 0x49, 0xc6, 0x13, 0xf4, 0x04, 0x1e, 0xcd, 0x49, 0x94, 0x51, 0x13,
	0xb6, 0x8d, 0xf3, 0x85, 0xfb, 0x4b, 0x05, 0xba, 0x7d, 0x12, 0x84, 0x74, 0x32, 0x32, 0x5d, 0x7e,
	0x4d, 0x52, 0xf4, 0x29, 0xd4, 0xf3, 0x96, 0x5b, 0x85, 0xcf, 0xd6, 0x47, 0xbc, 0xdb, 0x80, 0x2d,
	0x1c, 0x7d, 0x06, 0x0d, 0x61, 0xc3, 0xad, 0x17, 0x5b, 0xd2, 0x84, 0xef, 0xe0, 0xee, 0x9f, 0x55,
	0x78, 0x62, 0xbd, 0x23, 0x2a, 0xe6, 0x2c, 0xa0, 0x7d, 0x9e, 0x4c, 0xd9, 0x0c, 0x7d, 0x04, 0xfb,
	0x59, 0xaa, 0xdb, 0xec, 0x4f, 0x98, 0xa0, 0x81, 0xe2, 0x62, 0x61, 0x2b, 0xde, 0xcd, 0xed, 0x83,
	0xc2, 0x8c, 0x86, 0xd0, 0x4a, 0xa9, 0x88, 0x99, 0xd4, 0x8c, 0xd2, 0x2a, 0xf0, 0xd6, 0x2a, 0x58,
	0x89, 0xe1, 0x0d, 0xdf, 0xed, 0xc2, 0xcb, 0x14, 0xce, 0xef, 0x15, 0x68, 0x2d, 0x39, 0xd1, 0x31,
	0x34, 0x49, 0x14, 0xf1, 0xb7, 0x3e, 0x49, 0x72, 0x15, 0x0d, 0xdc, 0x30, 0x86, 0x8b, 0x64, 0x81,
	0xbe, 0x85, 0xb6, 0x79, 0xa7, 0x13, 0x3f, 0x93, 0x54, 0x1c, 0x55, 0x4f, 0x76, 0x7a, 0xad, 0xb3,
	0xf3, 0xf7, 0x8b, 0xef, 0xdd, 0x4a, 0x2a, 0x70, 0xcb, 0x12, 0xe9, 0x85, 0xe3, 0x42, 0x4d, 0x3f,
	0x91, 0x03, 0x0d, 0x36, 0xa1, 0x89, 0x62, 0x4a, 0xc7, 0xde, 0xe9, 0x35, 0xf1, 0xdd, 0xda, 0xfd,
	0xb5, 0x06, 0x07, 0x4b, 0xd4, 0x54, 0xd8, 0xea, 0x1d, 0x42, 0x3d, 0x62, 0x52, 0xd1, 0xc4, 0xd6,
	0xcc, 0xae, 0xd0, 0xe7, 0xb0, 0x2b, 0x73, 0x09, 0xb6, 0x4c, 0xee, 0x76, 0x99, 0xb8, 0xd8, 0x82,
	0x7e, 0x80, 0xae, 0x94, 0x91, 0x1f, 0x08, 0x6a, 0xe2, 0x93, 0x48, 0x1e, 0xed, 0x18, 0x96, 0x17,
	0xff, 0xc8, 0x52, 0x28, 0xf2, 0x46, 0x32, 0xea, 0xbf, 0xdb, 0xf7, 0xe5, 0xff, 0x70, 0x47, 0xae,
	0x58, 0x9c, 0x3f, 0xaa, 0xd0, 0x59, 0x05, 0xa1, 0xe7, 0x70, 0x90, 0xd2, 0xd8, 0x17, 0x9c, 0x2b,
	0x3f, 0xa0, 0x42, 0x49, 0x3f, 0x25, 0x2a, 0xb4, 0x29, 0xed, 0xa7, 0x34, 0xc6, 0x9c, 0xab, 0xbe,
	0x76, 0x0c, 0x89, 0x0a, 0xd1, 0x8f, 0xf0, 0x58, 0xc3, 0xdf, 0xd0, 0x85, 0x41, 0xfb, 0x29, 0x61,
	0x45, 0x37, 0xbe, 0x78, 0x5f, 0x81, 0xde, 0x90, 0xc6, 0x37, 0x74, 0xa1, 0xc9, 0x87, 0x84, 0x09,
	0xdc, 0x49, 0x57, 0xd6, 0xe8, 0x63, 0x78, 0x3c, 0xe5, 0x22, 0xa0, 0x7e, 0x10, 0x31, 0x9a, 0x28,
	0x9f, 0x64, 0x2a, 0x34, 0xc5, 0x68, 0xe0, 0xae, 0x71, 0xf4, 0x8d, 0xfd, 0x22, 0x53, 0xa1, 0x33,
	0x86, 0xce, 0x2a, 0x1b, 0xea, 0xc1, 0x7e, 0x2a, 0xd8, 0x9c, 0x28, 0x6a, 0xd4, 0x2e, 0x65, 0xd5,
	0xb1, 0xf6, 0x1b, 0xba, 0x30, 0x39, 0x7d, 0x00, 0x5d, 0x93, 0x4b, 0x10, 0x12, 0x96, 0xe4, 0xc0,
	0x7c, 0xca, 0xec, 0x69, 0x73, 0x5f, 0x5b, 0x35, 0xee, 0x72, 0x0f, 0x5a, 0x4b, 0x6d, 0x39, 0xfb,
	0xad, 0x09, 0xbb, 0x36, 0x49, 0xf4, 0x12, 0xea, 0xb7, 0xe6, 0xc4, 0xa0, 0x83, 0xd5, 0x2a, 0x98,
	0xa9, 0xec, 0x6c, 0x3b, 0xe5, 0xbd, 0x0a, 0x7a, 0x09, 0x8d, 0x62, 0xe8, 0xa2, 0xd2, 0xc9, 0x2e,
	0x0d, 0x63, 0x67, 0x5d, 0x88, 0x17, 0x15, 0x74, 0x0d, 0xf5, 0x7c, 0x88, 0xa2, 0xd2, 0xd8, 0x5b,
	0x19, 0xad, 0x8e, 0xbb, 0x49, 0x0b, 0xa6, 0x32, 0x8b, 0x14, 0x1a, 0x40, 0xe3, 0xd5, 0xcf, 0x4c,
	0x2a, 0x96, 0xcc, 0xd0, 0xa6, 0x19, 0xea, 0x6c, 0x72, 0xa2, 0x4b, 0x68, 0x15, 0x2c, 0x17, 0x51,
	0x84, 0x0e, 0xbd, 0xfc, 0x06, 0xf3, 0x8a, 0x1b, 0xcc, 0x7b, 0xa5, 0x6f, 0xb0, 0xcd, 0x1c, 0x57,
	0x50, 0xcf, 0x95, 0x6d, 0xd6, 0xb1, 0xad, 0xc0, 0x68, 0x00, 0xcd, 0x7c, 0xb1, 0x49, 0xc9, 0x56,
	0x16, 0x0c, 0xe8, 0x8e, 0xe5, 0x7a, 0x9a, 0xdf, 0x3e, 0x7f, 0x6b, 0x57, 0x69, 0x10, 0x3b, 0x25,
	0x77, 0xf9, 0x46, 0xf8, 0x1a, 0xda, 0xd7, 0xe6, 0x3f, 0xc1, 0xd6, 0xfe, 0x3e, 0x79, 0xe6, 0x04,
	0x9a, 0xed, 0x0a, 0xea, 0xf9, 0xe2, 0xe1, 0xf5, 0xca, 0x79, 0x1e, 0x54, 0xaf, 0x01, 0x34, 0xbe,
	0x63, 0x2a, 0xd4, 0xf7, 0xe7, 0xc3, 0xbe, 0xa3, 0x82, 0xe5, 0xde, 0xdf, 0xd1, 0x6b, 0x68, 0x8c,
	0xa8, 0x32, 0x7f, 0x0a, 0xe8, 0xa4, 0x7c, 0x7e, 0xca, 0x3f, 0x11, 0xdb, 0x13, 0xfb, 0x06, 0xe0,
	0x36, 0x91, 0xff, 0x21, 0xe1, 0x57, 0x00, 0xfd, 0x88, 0x12, 0x91, 0x13, 0x3e, 0xa8, 0x77, 0x97,
	0xcd, 0xef, 0x77, 0xad, 0x73, 0x5c, 0x37, 0x35, 0x3a, 0xff, 0x2b, 0x00, 0x00, 0xff, 0xff, 0xdf,
	0xbc, 0x17, 0x3b, 0x0a, 0x0b, 0x00, 0x00,
}

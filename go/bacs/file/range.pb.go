// Code generated by protoc-gen-go. DO NOT EDIT.
// source: bacs/file/range.proto

package file

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type Range_Whence int32

const (
	Range_BEGIN Range_Whence = 0
	Range_END   Range_Whence = 1
)

var Range_Whence_name = map[int32]string{
	0: "BEGIN",
	1: "END",
}
var Range_Whence_value = map[string]int32{
	"BEGIN": 0,
	"END":   1,
}

func (x Range_Whence) String() string {
	return proto.EnumName(Range_Whence_name, int32(x))
}
func (Range_Whence) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{0, 0} }

type Range struct {
	// / Position from which offset will be calculated.
	Whence Range_Whence `protobuf:"varint,1,opt,name=whence,enum=bacs.file.Range_Whence" json:"whence,omitempty"`
	// !
	// Negative or positive offset
	// from position specified by whence field.
	Offset int64 `protobuf:"varint,2,opt,name=offset" json:"offset,omitempty"`
	// !
	// Size of chunk will be transmitted.
	//
	// \note If EOF reached size of chunk may be smaller.
	Size uint64 `protobuf:"varint,3,opt,name=size" json:"size,omitempty"`
}

func (m *Range) Reset()                    { *m = Range{} }
func (m *Range) String() string            { return proto.CompactTextString(m) }
func (*Range) ProtoMessage()               {}
func (*Range) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

func (m *Range) GetWhence() Range_Whence {
	if m != nil {
		return m.Whence
	}
	return Range_BEGIN
}

func (m *Range) GetOffset() int64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *Range) GetSize() uint64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func init() {
	proto.RegisterType((*Range)(nil), "bacs.file.Range")
	proto.RegisterEnum("bacs.file.Range_Whence", Range_Whence_name, Range_Whence_value)
}

func init() { proto.RegisterFile("bacs/file/range.proto", fileDescriptor1) }

var fileDescriptor1 = []byte{
	// 165 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x12, 0x4d, 0x4a, 0x4c, 0x2e,
	0xd6, 0x4f, 0xcb, 0xcc, 0x49, 0xd5, 0x2f, 0x4a, 0xcc, 0x4b, 0x4f, 0xd5, 0x2b, 0x28, 0xca, 0x2f,
	0xc9, 0x17, 0xe2, 0x04, 0x09, 0xeb, 0x81, 0x84, 0x95, 0x9a, 0x18, 0xb9, 0x58, 0x83, 0x40, 0x52,
	0x42, 0xfa, 0x5c, 0x6c, 0xe5, 0x19, 0xa9, 0x79, 0xc9, 0xa9, 0x12, 0x8c, 0x0a, 0x8c, 0x1a, 0x7c,
	0x46, 0xe2, 0x7a, 0x70, 0x55, 0x7a, 0x60, 0x15, 0x7a, 0xe1, 0x60, 0xe9, 0x20, 0xa8, 0x32, 0x21,
	0x31, 0x2e, 0xb6, 0xfc, 0xb4, 0xb4, 0xe2, 0xd4, 0x12, 0x09, 0x26, 0x05, 0x46, 0x0d, 0xe6, 0x20,
	0x28, 0x4f, 0x48, 0x88, 0x8b, 0xa5, 0x38, 0xb3, 0x2a, 0x55, 0x82, 0x59, 0x81, 0x51, 0x83, 0x25,
	0x08, 0xcc, 0x56, 0x92, 0xe1, 0x62, 0x83, 0xe8, 0x16, 0xe2, 0xe4, 0x62, 0x75, 0x72, 0x75, 0xf7,
	0xf4, 0x13, 0x60, 0x10, 0x62, 0xe7, 0x62, 0x76, 0xf5, 0x73, 0x11, 0x60, 0x74, 0x62, 0x8b, 0x62,
	0x01, 0x59, 0x93, 0xc4, 0x06, 0x76, 0x9e, 0x31, 0x20, 0x00, 0x00, 0xff, 0xff, 0xee, 0x0f, 0x31,
	0xca, 0xb7, 0x00, 0x00, 0x00,
}

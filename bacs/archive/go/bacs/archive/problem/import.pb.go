// Code generated by protoc-gen-go.
// source: bacs/archive/problem/import.proto
// DO NOT EDIT!

package problem

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import bacs_problem "github.com/bacsorg/problem/go/bacs/problem"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type ImportResult struct {
	// Types that are valid to be assigned to Result:
	//	*ImportResult_Error
	//	*ImportResult_Problem
	Result isImportResult_Result `protobuf_oneof:"result"`
}

func (m *ImportResult) Reset()         { *m = ImportResult{} }
func (m *ImportResult) String() string { return proto.CompactTextString(m) }
func (*ImportResult) ProtoMessage()    {}

type isImportResult_Result interface {
	isImportResult_Result()
}

type ImportResult_Error struct {
	Error *Error `protobuf:"bytes,1,opt,name=error,oneof"`
}
type ImportResult_Problem struct {
	Problem *bacs_problem.Problem `protobuf:"bytes,2,opt,name=problem,oneof"`
}

func (*ImportResult_Error) isImportResult_Result()   {}
func (*ImportResult_Problem) isImportResult_Result() {}

func (m *ImportResult) GetResult() isImportResult_Result {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *ImportResult) GetError() *Error {
	if x, ok := m.GetResult().(*ImportResult_Error); ok {
		return x.Error
	}
	return nil
}

func (m *ImportResult) GetProblem() *bacs_problem.Problem {
	if x, ok := m.GetResult().(*ImportResult_Problem); ok {
		return x.Problem
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ImportResult) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), []interface{}) {
	return _ImportResult_OneofMarshaler, _ImportResult_OneofUnmarshaler, []interface{}{
		(*ImportResult_Error)(nil),
		(*ImportResult_Problem)(nil),
	}
}

func _ImportResult_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ImportResult)
	// result
	switch x := m.Result.(type) {
	case *ImportResult_Error:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Error); err != nil {
			return err
		}
	case *ImportResult_Problem:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Problem); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ImportResult.Result has unexpected type %T", x)
	}
	return nil
}

func _ImportResult_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ImportResult)
	switch tag {
	case 1: // result.error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Error)
		err := b.DecodeMessage(msg)
		m.Result = &ImportResult_Error{msg}
		return true, err
	case 2: // result.problem
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(bacs_problem.Problem)
		err := b.DecodeMessage(msg)
		m.Result = &ImportResult_Problem{msg}
		return true, err
	default:
		return false, nil
	}
}

type ImportMap struct {
	Entry map[string]*ImportResult `protobuf:"bytes,1,rep,name=entry" json:"entry,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *ImportMap) Reset()         { *m = ImportMap{} }
func (m *ImportMap) String() string { return proto.CompactTextString(m) }
func (*ImportMap) ProtoMessage()    {}

func (m *ImportMap) GetEntry() map[string]*ImportResult {
	if m != nil {
		return m.Entry
	}
	return nil
}
